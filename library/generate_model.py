"""
Dynamic Python model execution module for Ansible.

This module provides functionality to dynamically load and execute Python models
from within Ansible playbooks, supporting custom CloudFormation generation,
API interactions, and other infrastructure automation tasks.
"""

import os
import sys
import traceback
from importlib import import_module
from os.path import abspath, exists, split

import stringcase
from ansible.module_utils.basic import AnsibleModule

ANSIBLE_METADATA = {
    "metadata_version": "1.0",
    "status": ["preview"],
    "supported_by": "community",
}

DOCUMENTATION = """
---
module: generate_model

short_description: Dynamic execution of Python models within Ansible playbooks

version_added: "2.5"

description:
    - Dynamically loads and executes Python model classes from specified file paths
    - Models must implement a generate(params, description, ansible) method
    - Supports custom CloudFormation template generation, API interactions, and infrastructure automation
    - Model class names must follow PascalCase convention based on file name (e.g., my_model.py -> MyModel)
    - Automatically handles module path resolution and Python import mechanics

options:
    model:
        description:
            - Relative path to the Python model file from the playbook working directory
            - Path should exclude the .py extension
        required: true
        type: str
    parameters:
        description:
            - Dictionary of parameters to pass to the model's generate method
            - Parameters are model-specific and depend on implementation requirements
        required: false
        type: dict
        default: {}
    description:
        description:
            - Optional descriptive text passed to the model for context or documentation
            - Can be used by models for logging, template comments, or metadata
        required: false
        type: str
        default: null

author:
    - SplendidCube Development Team

requirements:
    - stringcase
    - Python models must be accessible via standard import mechanisms
    - Model files must be in directories with __init__.py files (proper Python packages)
"""

EXAMPLES = """
# Basic model execution with parameters
- generate_model:
    model: models/ssh_server
    description: Create an EC2 instance configured for SSH access
    parameters:
      ec2_instances:
        - { id: ami-d834aba1, type: t3.micro }
      security_groups:
        - { protocol: tcp, from: 22, to: 22, cidr: 0.0.0.0/0 }

# CloudFormation template generation
- generate_model:
    model: infrastructure/vpc_setup
    description: Generate VPC CloudFormation template
    parameters:
      vpc_cidr: "10.0.0.0/16"
      availability_zones: ["eu-west-1a", "eu-west-1b"]
      enable_dns: true

# Simple model execution without parameters
- generate_model:
    model: utilities/health_check
    description: System health validation
"""

RETURN = """
output:
    description:
        - Primary output generated by the model execution
        - Content and format depend on the specific model implementation
        - May contain CloudFormation templates, API responses, or custom data structures
    type: str
    returned: always
    sample: "Generated CloudFormation template content"

changed:
    description: Indicates whether the module execution resulted in any changes
    type: bool
    returned: always
    sample: false

failed:
    description: Indicates whether the module execution failed
    type: bool
    returned: on failure
    sample: false

msg:
    description: Human-readable message describing the execution result or error
    type: str
    returned: on failure
    sample: "Model executed successfully"
"""


def get_path(model: str) -> str:
    """
    Resolve and validate the absolute file path for a Python model.

    Converts a relative model path to an absolute path, validates file existence,
    and returns the path without the .py extension for import compatibility.

    :param model: Relative path to the model file (excluding .py extension)
    :type model: str
    :returns: Absolute path to the model file without .py extension
    :rtype: str
    :raises FileNotFoundError: If the resolved file path does not exist
    :raises ValueError: If the model path is empty or invalid

    Example::

        path = get_path("models/vpc_builder")
        # Returns: "/full/path/to/models/vpc_builder"
    """
    if not model or not isinstance(model, str):
        raise ValueError("Model path must be a non-empty string")

    # Normalize path separators and resolve to absolute path
    normalized_model = model.replace("\\", os.sep).replace("/", os.sep)
    file_path = abspath(normalized_model + ".py")

    if not exists(file_path):
        raise FileNotFoundError(f"Model file '{file_path}' not found")

    # Return path without .py extension for import compatibility
    return file_path[:-3]


def get_module_path(file_path: str) -> tuple[str, str]:
    """
    Resolve Python module path from absolute file path.

    Traverses the directory structure to find the root Python package and
    constructs the appropriate module import path. Supports nested packages
    and handles complex directory structures.

    :param file_path: Absolute path to the Python module file
    :type file_path: str
    :returns: Tuple of (base_module_path, dotted_module_name)
    :rtype: Tuple[str, str]
    :raises ModuleNotFoundError: If no valid Python package structure is found
    :raises ValueError: If the file path is invalid

    Example::

        base_path, module_name = get_module_path("/path/to/models/aws/vpc_builder")
        # Returns: ("/path/to", "models.aws.vpc_builder")
    """
    if not file_path or not isinstance(file_path, str):
        raise ValueError("File path must be a non-empty string")

    file_path_parts = file_path.split(os.sep)
    deep_module_name = []

    # Validate that we're working with a proper Python package
    parent_dir = os.sep.join(file_path_parts[:-1])
    if not exists(os.path.join(parent_dir, "__init__.py")):
        raise ModuleNotFoundError(
            f"No Python package found at '{parent_dir}'. "
            "Ensure the directory contains an __init__.py file."
        )

    # Traverse directory structure to find package root
    for _ in range(len(file_path_parts) - 1):
        module_segment = file_path_parts.pop()
        current_path = os.sep.join(file_path_parts)
        deep_module_name.append(module_segment)

        # Check if parent directory is still part of a Python package
        init_file = os.path.join(current_path, "__init__.py")
        if not exists(init_file):
            # Found the package root
            break

    if not deep_module_name:
        raise ModuleNotFoundError(f"Unable to determine module path for '{file_path}'")

    return current_path, ".".join(reversed(deep_module_name))


def run_module() -> None:
    """
    Main module execution logic for the generate_model Ansible module.

    Handles parameter validation, model loading, dynamic class instantiation,
    and execution of the model's generate method. Provides comprehensive
    error handling and detailed feedback for troubleshooting.

    :raises SystemExit: Via AnsibleModule.fail_json() on any execution error
    """
    # Configure Python path for Ansible Galaxy roles and local roles
    additional_paths = [
        os.path.join(os.getcwd(), "roles.galaxy"),
        os.path.join(os.getcwd(), "roles"),
        os.getcwd(),  # Add current directory for relative imports
    ]

    for path in additional_paths:
        if path not in sys.path:
            sys.path.insert(0, path)

    # Define module arguments with comprehensive validation
    module_args = {
        "model": {
            "type": "str",
            "required": True,
            "no_log": False,
        },
        "description": {
            "type": "str",
            "required": False,
            "default": None,
        },
        "parameters": {
            "type": "dict",
            "required": False,
            "default": {},
        },
    }

    # Initialize result dictionary with default values
    result = {
        "output": "",
        "changed": False,
        "failed": False,
    }

    # Initialize variables to avoid UnboundLocalError in exception handlers
    file_path = ""
    module_base_path = ""
    module_import_path = ""
    class_name = ""
    model_module = None
    model_instance = None

    # Create AnsibleModule instance with argument validation
    module = AnsibleModule(
        argument_spec=module_args,
        supports_check_mode=True,
    )

    try:
        # Validate and resolve model file path
        model_param = module.params["model"].strip()
        if not model_param:
            raise ValueError("Model parameter cannot be empty")

        file_path = get_path(model_param)

    except (FileNotFoundError, ValueError) as e:
        module.fail_json(msg=f"Model path validation failed: {str(e)}", **result)
        return
    except Exception as e:
        module.fail_json(
            msg=f"Unexpected error during path resolution: {str(e)}",
            traceback=traceback.format_exc().split("\n"),
            **result,
        )
        return

    # Extract module and class names
    try:
        _, module_name = split(model_param)
        if not module_name:
            raise ValueError("Invalid model name extracted from path")

        class_name = stringcase.pascalcase(module_name)
        if not class_name:
            raise ValueError("Unable to generate valid class name")

        module_base_path, module_import_path = get_module_path(file_path)

    except Exception as e:
        module.fail_json(msg=f"Module path resolution failed: {str(e)}", **result)
        return

    # Import the model module
    try:
        if module_base_path not in sys.path:
            sys.path.insert(0, module_base_path)

        model_module = import_module(module_import_path)

    except ImportError as e:
        module.fail_json(
            msg=f"Cannot import module '{module_import_path}': {str(e)}",
            hint="Ensure the module exists and all dependencies are available",
            **result,
        )
        return
    except Exception as e:
        module.fail_json(
            msg=f"Unexpected error importing module '{module_import_path}': {str(e)}",
            traceback=traceback.format_exc().split("\n"),
            **result,
        )
        return

    # Instantiate the model class
    try:
        if not hasattr(model_module, class_name):
            available_classes = [
                attr
                for attr in dir(model_module)
                if not attr.startswith("_") and callable(getattr(model_module, attr))
            ]
            module.fail_json(
                msg=f"Class '{class_name}' not found in module '{module_import_path}'",
                hint=f"Available classes: {available_classes}",
                expected_class=class_name,
                **result,
            )
            return

        model_class = getattr(model_module, class_name)
        model_instance = model_class()

    except TypeError as e:
        module.fail_json(
            msg=f"Cannot instantiate class '{class_name}': {str(e)}",
            hint="Ensure the class constructor accepts no arguments or has appropriate defaults",
            **result,
        )
        return
    except Exception as e:
        module.fail_json(
            msg=f"Unexpected error instantiating class '{class_name}': {str(e)}",
            traceback=traceback.format_exc().split("\n"),
            **result,
        )
        return

    # Execute the model's generate method
    try:
        # Validate that the generate method exists
        if not hasattr(model_instance, "generate") or not callable(
            model_instance.generate
        ):
            module.fail_json(
                msg=f"Class '{class_name}' must implement a 'generate' method",
                hint="The generate method should accept params, description, and ansible arguments",
                **result,
            )
            return

        # Call the generate method with proper error context
        response = model_instance.generate(
            params=module.params["parameters"],
            description=module.params["description"],
            ansible=module,
        )

        # Process the response based on its type
        if isinstance(response, dict):
            result.update(response)
        elif response is not None:
            result["output"] = str(response)
        else:
            result["output"] = ""

        # Set success message if not already provided
        if not result.get("msg"):
            result["msg"] = f"Model '{class_name}' executed successfully"

    except Exception as e:
        error_msg = (
            f"Error executing generate() method on class '{class_name}': {str(e)}"
        )
        module.fail_json(
            msg=error_msg,
            error_details=str(e),
            traceback=traceback.format_exc().split("\n"),
            model_class=class_name,
            model_module=module_import_path,
            **result,
        )
        return

    # Return successful execution result
    module.exit_json(**result)


def main() -> None:
    """
    Entry point for the generate_model Ansible module.

    This function serves as the primary entry point when the module is executed
    by Ansible. It delegates execution to the run_module function which contains
    the main logic.
    """
    run_module()


if __name__ == "__main__":
    main()
